// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: schema.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPlaylist = `-- name: CreatePlaylist :exec





INSERT INTO playlists (id, title, thumbnail, tracks, allowed_tracks)
VALUES ($1, $2, $3, $4, $5)
`

type CreatePlaylistParams struct {
	ID            string
	Title         string
	Thumbnail     string
	Tracks        []string
	AllowedTracks []string
}

// INIT DATABASE TABLES / SCHEMA END
// =================================
// PLAYLISTS CRUD BEGIN
func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) error {
	_, err := q.db.Exec(ctx, createPlaylist,
		arg.ID,
		arg.Title,
		arg.Thumbnail,
		arg.Tracks,
		arg.AllowedTracks,
	)
	return err
}

const createRole = `-- name: CreateRole :exec





INSERT INTO playlist_permissions (playlist_id, user_id, role)
VALUES ($1, $2, $3)
`

type CreateRoleParams struct {
	PlaylistID string
	UserID     int64
	Role       interface{}
}

// TRACKS CRUD END
// =================================
// ROLES CRUD BEGIN
func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) error {
	_, err := q.db.Exec(ctx, createRole, arg.PlaylistID, arg.UserID, arg.Role)
	return err
}

const createTrack = `-- name: CreateTrack :exec





INSERT INTO tracks (id, title, authors, thumbnail, length, explicit)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateTrackParams struct {
	ID        string
	Title     string
	Authors   string
	Thumbnail string
	Length    int32
	Explicit  bool
}

// USERS CRUD END
// =================================
// TRACKS CRUD BEGIN
func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) error {
	_, err := q.db.Exec(ctx, createTrack,
		arg.ID,
		arg.Title,
		arg.Authors,
		arg.Thumbnail,
		arg.Length,
		arg.Explicit,
	)
	return err
}

const createUser = `-- name: CreateUser :exec





INSERT INTO users (id, name) VALUES ($1, $2)
`

type CreateUserParams struct {
	ID   int64
	Name string
}

// PLAYLISTS CRUD END
// =================================
// USERS CRUD BEGIN
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser, arg.ID, arg.Name)
	return err
}

const deletePlaylist = `-- name: DeletePlaylist :exec
DELETE FROM playlists WHERE id = $1
`

func (q *Queries) DeletePlaylist(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deletePlaylist, id)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM playlist_permissions
WHERE playlist_id = $1 AND user_id = $2
`

type DeleteRoleParams struct {
	PlaylistID string
	UserID     int64
}

func (q *Queries) DeleteRole(ctx context.Context, arg DeleteRoleParams) error {
	_, err := q.db.Exec(ctx, deleteRole, arg.PlaylistID, arg.UserID)
	return err
}

const editPlaylist = `-- name: EditPlaylist :exec
UPDATE playlists
SET
    title = COALESCE($2, title),
    thumbnail = COALESCE($3, thumbnail),
    tracks = COALESCE($4, tracks),
    allowed_tracks = COALESCE($5, allowed_tracks)
WHERE id = $1
`

type EditPlaylistParams struct {
	ID            string
	Title         string
	Thumbnail     string
	Tracks        []string
	AllowedTracks []string
}

func (q *Queries) EditPlaylist(ctx context.Context, arg EditPlaylistParams) error {
	_, err := q.db.Exec(ctx, editPlaylist,
		arg.ID,
		arg.Title,
		arg.Thumbnail,
		arg.Tracks,
		arg.AllowedTracks,
	)
	return err
}

const editRole = `-- name: EditRole :exec
UPDATE playlist_permissions
SET role = $3
WHERE playlist_id = $1 AND user_id = $2
`

type EditRoleParams struct {
	PlaylistID string
	UserID     int64
	Role       interface{}
}

func (q *Queries) EditRole(ctx context.Context, arg EditRoleParams) error {
	_, err := q.db.Exec(ctx, editRole, arg.PlaylistID, arg.UserID, arg.Role)
	return err
}

const editUser = `-- name: EditUser :exec
UPDATE users SET name = $2 WHERE id = $1
`

type EditUserParams struct {
	ID   int64
	Name string
}

func (q *Queries) EditUser(ctx context.Context, arg EditUserParams) error {
	_, err := q.db.Exec(ctx, editUser, arg.ID, arg.Name)
	return err
}

const getPlaylistById = `-- name: GetPlaylistById :one
SELECT id, title, thumbnail, tracks, allowed_tracks, length, allowed_length FROM playlists WHERE id = $1
`

func (q *Queries) GetPlaylistById(ctx context.Context, id string) (Playlist, error) {
	row := q.db.QueryRow(ctx, getPlaylistById, id)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Thumbnail,
		&i.Tracks,
		&i.AllowedTracks,
		&i.Length,
		&i.AllowedLength,
	)
	return i, err
}

const getPlaylistByPlaylistId = `-- name: GetPlaylistByPlaylistId :many
SELECT
    p.playlist_id,
    p.user_id,
    u.name AS user_name,  -- New: include user name
    p.role,
    pl.title AS playlist_title,
    pl.thumbnail,
    pl.length AS track_count,
    pl.allowed_length AS allowed_count
FROM playlist_permissions p
         JOIN playlists pl ON p.playlist_id = pl.id
         JOIN users u ON p.user_id = u.id  -- Join users table
WHERE p.playlist_id = $1
`

type GetPlaylistByPlaylistIdRow struct {
	PlaylistID    string
	UserID        int64
	UserName      string
	Role          interface{}
	PlaylistTitle string
	Thumbnail     string
	TrackCount    pgtype.Int4
	AllowedCount  pgtype.Int4
}

func (q *Queries) GetPlaylistByPlaylistId(ctx context.Context, playlistID string) ([]GetPlaylistByPlaylistIdRow, error) {
	rows, err := q.db.Query(ctx, getPlaylistByPlaylistId, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistByPlaylistIdRow
	for rows.Next() {
		var i GetPlaylistByPlaylistIdRow
		if err := rows.Scan(
			&i.PlaylistID,
			&i.UserID,
			&i.UserName,
			&i.Role,
			&i.PlaylistTitle,
			&i.Thumbnail,
			&i.TrackCount,
			&i.AllowedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistByUserId = `-- name: GetPlaylistByUserId :many
SELECT
    p.playlist_id,
    p.user_id,
    u.name AS user_name,  -- New: include user name
    p.role,
    pl.title AS playlist_title,
    pl.thumbnail,
    pl.length AS track_count,
    pl.allowed_length AS allowed_count
FROM playlist_permissions p
         JOIN playlists pl ON p.playlist_id = pl.id
         JOIN users u ON p.user_id = u.id  -- Join users table
WHERE p.user_id = $1
`

type GetPlaylistByUserIdRow struct {
	PlaylistID    string
	UserID        int64
	UserName      string
	Role          interface{}
	PlaylistTitle string
	Thumbnail     string
	TrackCount    pgtype.Int4
	AllowedCount  pgtype.Int4
}

func (q *Queries) GetPlaylistByUserId(ctx context.Context, userID int64) ([]GetPlaylistByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getPlaylistByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistByUserIdRow
	for rows.Next() {
		var i GetPlaylistByUserIdRow
		if err := rows.Scan(
			&i.PlaylistID,
			&i.UserID,
			&i.UserName,
			&i.Role,
			&i.PlaylistTitle,
			&i.Thumbnail,
			&i.TrackCount,
			&i.AllowedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrackById = `-- name: GetTrackById :one
SELECT id, title, authors, thumbnail, length, explicit FROM tracks WHERE id = $1
`

func (q *Queries) GetTrackById(ctx context.Context, id string) (Track, error) {
	row := q.db.QueryRow(ctx, getTrackById, id)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Authors,
		&i.Thumbnail,
		&i.Length,
		&i.Explicit,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, name FROM users WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getUserPlaylists = `-- name: GetUserPlaylists :many
SELECT
    pl.id, pl.title, pl.thumbnail, pl.tracks, pl.allowed_tracks, pl.length, pl.allowed_length,
    p.role,
    u.name AS user_name  -- New: include user name
FROM playlists pl
         JOIN playlist_permissions p ON pl.id = p.playlist_id
         JOIN users u ON p.user_id = u.id  -- Join users table
WHERE p.user_id = $1
`

type GetUserPlaylistsRow struct {
	ID            string
	Title         string
	Thumbnail     string
	Tracks        []string
	AllowedTracks []string
	Length        pgtype.Int4
	AllowedLength pgtype.Int4
	Role          interface{}
	UserName      string
}

func (q *Queries) GetUserPlaylists(ctx context.Context, userID int64) ([]GetUserPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getUserPlaylists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPlaylistsRow
	for rows.Next() {
		var i GetUserPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Thumbnail,
			&i.Tracks,
			&i.AllowedTracks,
			&i.Length,
			&i.AllowedLength,
			&i.Role,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initPermissions = `-- name: InitPermissions :exec
CREATE TABLE IF NOT EXISTS playlist_permissions (
    playlist_id TEXT NOT NULL REFERENCES playlists(id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES users(id),
    role playlist_role NOT NULL,
    PRIMARY KEY (playlist_id, user_id)
)
`

func (q *Queries) InitPermissions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initPermissions)
	return err
}

const initPlaylists = `-- name: InitPlaylists :exec

CREATE TABLE IF NOT EXISTS playlists (
    id TEXT NOT NULL PRIMARY KEY UNIQUE,
    title TEXT NOT NULL,
    thumbnail TEXT NOT NULL,
    tracks TEXT[] DEFAULT '{}',
    allowed_tracks TEXT[] DEFAULT '{}',
    length INTEGER GENERATED ALWAYS AS (COALESCE(array_length(tracks, 1), 0)) STORED,
    allowed_length INTEGER GENERATED ALWAYS AS (COALESCE(array_length(allowed_tracks, 1), 0)) STORED
)
`

// INIT DATABASE TABLES / SCHEMA BEGIN
func (q *Queries) InitPlaylists(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initPlaylists)
	return err
}

const initRoleEnum = `-- name: InitRoleEnum :exec
DO $$ BEGIN
    CREATE TYPE playlist_role AS ENUM ('viewer', 'moderator', 'owner');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$
`

func (q *Queries) InitRoleEnum(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initRoleEnum)
	return err
}

const initTracks = `-- name: InitTracks :exec
CREATE TABLE IF NOT EXISTS tracks (
    id TEXT NOT NULL PRIMARY KEY,
    title TEXT NOT NULL,
    authors TEXT NOT NULL,
    thumbnail TEXT NOT NULL,
    length INTEGER NOT NULL,
    explicit BOOLEAN NOT NULL DEFAULT FALSE
)
`

func (q *Queries) InitTracks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initTracks)
	return err
}

const initUsers = `-- name: InitUsers :exec
CREATE TABLE IF NOT EXISTS users (
    id BIGINT NOT NULL PRIMARY KEY,
    name TEXT NOT NULL
)
`

func (q *Queries) InitUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initUsers)
	return err
}
